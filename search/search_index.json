{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Cython Extensions SC2","text":""},{"location":"index.html#cython_extensions.combat_utils.cy_attack_ready","title":"cy_attack_ready","text":"<pre><code>cy_attack_ready(ai, unit, target)\n</code></pre> <p>Check if the unit is ready to attack the target.</p> <p>Takes into account turn rate and unit speeds</p> <p>Example: <pre><code>from cython_extensions import cy_attack_ready\n\nworker = self.workers[0]\ntarget = self.enemy_units[0]\n\nattack_ready: bool = cy_attack_ready(self, worker, target)\n</code></pre></p> <pre><code>1.46 \u00b5s \u00b1 5.45 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n\nPython alternative:\n5.66 \u00b5s \u00b1 21.2 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>ai</code> <code>BotAI</code> <p>Bot object that will be running the game.</p> required <code>unit</code> <code>Unit</code> <p>The unit we want to check.</p> required <code>target</code> <code>Unit</code> <p>The thing we want to shoot.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Is the unit ready to attack the target?</p> Source code in <code>cython_extensions/combat_utils.pyi</code> <pre><code>def cy_attack_ready(ai: BotAI, unit: Unit, target: Unit) -&gt; bool:\n    \"\"\"Check if the unit is ready to attack the target.\n\n    Takes into account turn rate and unit speeds\n\n    Example:\n    ```py\n    from cython_extensions import cy_attack_ready\n\n    worker = self.workers[0]\n    target = self.enemy_units[0]\n\n    attack_ready: bool = cy_attack_ready(self, worker, target)\n    ```\n\n    ```\n    1.46 \u00b5s \u00b1 5.45 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n\n    Python alternative:\n    5.66 \u00b5s \u00b1 21.2 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n    ```\n\n    Parameters\n    ----------\n    ai :\n        Bot object that will be running the game.\n    unit :\n        The unit we want to check.\n    target :\n        The thing we want to shoot.\n\n    Returns\n    -------\n    bool :\n        Is the unit ready to attack the target?\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.combat_utils.cy_is_facing","title":"cy_is_facing","text":"<pre><code>cy_is_facing(unit, other_unit, angle_error)\n</code></pre> <p>Get turn speed of unit in radians</p> <p>Example: <pre><code>from cython_extensions import cy_is_facing\n\nunit: Unit = self.workers[0]\nother_unit: Unit = self.townhalls[0]\nis_facing: bool = cy_is_facing(unit, other_unit)\n</code></pre> <pre><code>323 ns \u00b1 3.93 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n\nPython-sc2's `unit.is_facing(other_unit)` alternative:\n2.94 \u00b5s \u00b1 8 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>unit</code> <code>Unit</code> <p>The actual sc2.Unit object we are checking.</p> required <code>other_unit</code> <code>int</code> <p>The unit type id integer value.</p> required <code>angle_error</code> <code>(default=0.3)</code> <p>Some leeway when deciding a unit is facing.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Is facing the other unit?</p> Source code in <code>cython_extensions/combat_utils.pyi</code> <pre><code>def cy_is_facing(unit: Unit, other_unit: int, angle_error: float) -&gt; bool:\n    \"\"\"Get turn speed of unit in radians\n\n    Example:\n    ```py\n    from cython_extensions import cy_is_facing\n\n    unit: Unit = self.workers[0]\n    other_unit: Unit = self.townhalls[0]\n    is_facing: bool = cy_is_facing(unit, other_unit)\n    ```\n    ```\n    323 ns \u00b1 3.93 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n\n    Python-sc2's `unit.is_facing(other_unit)` alternative:\n    2.94 \u00b5s \u00b1 8 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n    ```\n\n    Parameters\n    ----------\n    unit :\n        The actual sc2.Unit object we are checking.\n    other_unit :\n        The unit type id integer value.\n    angle_error : (default=0.3)\n        Some leeway when deciding a unit is facing.\n\n    Returns\n    -------\n    bool :\n        Is facing the other unit?\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.combat_utils.cy_pick_enemy_target","title":"cy_pick_enemy_target","text":"<pre><code>cy_pick_enemy_target(enemies)\n</code></pre> <p>Pick the best thing to shoot at out of all enemies.</p> <p>Example: <pre><code>from cython_extensions import cy_pick_enemy_target\nfrom sc2.units import Units\nfrom sc2.unit import Unit\n\nenemies: Units = self.enemy_units\n\ntarget: Unit = cy_pick_enemy_target(enemies)\n</code></pre> <pre><code>70.5 \u00b5s \u00b1 818 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n\nPython alternative:\n115 \u00b5s \u00b1 766 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>enemies</code> <code>Union[Units, list[Unit]]</code> <p>All enemy units we would like to check.</p> required <p>Returns:</p> Name Type Description <code>Unit</code> <code>Unit</code> <p>The best unit to target.</p> Source code in <code>cython_extensions/combat_utils.pyi</code> <pre><code>def cy_pick_enemy_target(enemies: Union[Units, list[Unit]]) -&gt; Unit:\n    \"\"\"Pick the best thing to shoot at out of all enemies.\n\n    Example:\n    ```py\n    from cython_extensions import cy_pick_enemy_target\n    from sc2.units import Units\n    from sc2.unit import Unit\n\n    enemies: Units = self.enemy_units\n\n    target: Unit = cy_pick_enemy_target(enemies)\n    ```\n    ```\n    70.5 \u00b5s \u00b1 818 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n\n    Python alternative:\n    115 \u00b5s \u00b1 766 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n    ```\n\n    Parameters\n    ----------\n    enemies :\n        All enemy units we would like to check.\n\n    Returns\n    -------\n    Unit :\n        The best unit to target.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.general_utils.cy_pylon_matrix_covers","title":"cy_pylon_matrix_covers","text":"<pre><code>cy_pylon_matrix_covers(\n    position, pylons, height_grid, pylon_build_progress\n)\n</code></pre> <p>Check if a position is powered by a pylon.</p> <p>Example: <pre><code>from cython_functions import cy_pylon_matrix_covers\nfrom sc2.position import Point2\n\n# check if start location is powered by pylon\nposition: Point2 = self.start_location\n\ncan_place_structure_here: bool = cy_pylon_matrix_covers(\n    position,\n    self.structures(UnitTypeId.PYLON),\n    self.game_info.terrain_height.data_numpy\n)\n</code></pre></p> <pre><code>1.85 \u00b5s \u00b1 8.72 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>Union[Point2, tuple[float, float]]</code> <p>Position to check for power.</p> required <code>pylons</code> <code>Union[Units, list[Unit]]</code> <p>The pylons we want to check.</p> required <code>height_grid</code> <code>ndarray</code> <p>Height grid supplied from <code>python-sc2</code> as a numpy array.</p> required <code>pylon_build_progress</code> <code>Optional(default=1.0)</code> <p>If less than 1.0, check near pending pylons.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if <code>position</code> has power.</p> Source code in <code>cython_extensions/general_utils.pyi</code> <pre><code>def cy_pylon_matrix_covers(\n    position: Union[Point2, tuple[float, float]],\n    pylons: Union[Units, list[Unit]],\n    height_grid: np.ndarray,\n    pylon_build_progress: float,\n) -&gt; bool:\n    \"\"\"Check if a position is powered by a pylon.\n\n    Example:\n    ```py\n    from cython_functions import cy_pylon_matrix_covers\n    from sc2.position import Point2\n\n    # check if start location is powered by pylon\n    position: Point2 = self.start_location\n\n    can_place_structure_here: bool = cy_pylon_matrix_covers(\n        position,\n        self.structures(UnitTypeId.PYLON),\n        self.game_info.terrain_height.data_numpy\n    )\n    ```\n\n    ```\n    1.85 \u00b5s \u00b1 8.72 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n    ```\n\n    Parameters\n    ----------\n    position :\n        Position to check for power.\n    pylons :\n        The pylons we want to check.\n    height_grid :\n        Height grid supplied from `python-sc2` as a numpy array.\n    pylon_build_progress : Optional (default=1.0)\n        If less than 1.0, check near pending pylons.\n\n    Returns\n    -------\n    bool :\n        True if `position` has power.\n    \"\"\"\n</code></pre>"},{"location":"index.html#cython_extensions.general_utils.cy_unit_pending","title":"cy_unit_pending","text":"<pre><code>cy_unit_pending(ai, unit_type)\n</code></pre> <p>Check how many unit_type are pending.</p> <p>Faster unit specific alternative to <code>python-sc2</code>'s <code>already_pending</code></p> <p>Example: <pre><code>from cython_functions import cy_unit_pending\nfrom sc2.ids.unit_typeid import UnitTypeId\n\nnum_marines_pending: int = cy_unit_pending(UnitTypeId.MARINE)\n</code></pre> <pre><code>453 ns \u00b1 9.35 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n\nPython-sc2 `already_pending` alternative:\n2.82 \u00b5s \u00b1 29 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>ai</code> <code>BotAI</code> <p>Bot object that will be running the game.</p> required <code>unit_type</code> <code>UnitTypeId</code> <p>Unit type we want to check.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>How many unit_type are currently building.</p> Source code in <code>cython_extensions/general_utils.pyi</code> <pre><code>def cy_unit_pending(ai: \"BotAI\", unit_type: UnitID) -&gt; int:\n    \"\"\"Check how many unit_type are pending.\n\n    Faster unit specific alternative to `python-sc2`'s `already_pending`\n\n    Example:\n    ```py\n    from cython_functions import cy_unit_pending\n    from sc2.ids.unit_typeid import UnitTypeId\n\n    num_marines_pending: int = cy_unit_pending(UnitTypeId.MARINE)\n    ```\n    ```\n    453 ns \u00b1 9.35 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n\n    Python-sc2 `already_pending` alternative:\n    2.82 \u00b5s \u00b1 29 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n    ```\n\n    Parameters\n    ----------\n    ai :\n        Bot object that will be running the game.\n    unit_type :\n        Unit type we want to check.\n\n    Returns\n    -------\n    int :\n        How many unit_type are currently building.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.geometry.cy_angle_diff","title":"cy_angle_diff","text":"<pre><code>cy_angle_diff(a, b)\n</code></pre> <p>Absolute angle difference between 2 angles</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>First angle.</p> required <code>b</code> <code>float</code> <p>Second angle.</p> required <p>Returns:</p> Name Type Description <code>angle_difference</code> <code>float</code> Source code in <code>cython_extensions/geometry.pyi</code> <pre><code>def cy_angle_diff(a: float, b: float) -&gt; float:\n    \"\"\"Absolute angle difference between 2 angles\n\n    Parameters\n    ----------\n    a : float\n        First angle.\n    b : float\n        Second angle.\n\n    Returns\n    -------\n    angle_difference : float\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.geometry.cy_angle_to","title":"cy_angle_to","text":"<pre><code>cy_angle_to(from_pos, to_pos)\n</code></pre> <p>Angle from point to other point in radians</p> <p>Parameters:</p> Name Type Description Default <code>from_pos</code> <code>Union[Point2, tuple[float, float]]</code> <p>First 2D point.</p> required <code>to_pos</code> <code>Union[Point2, tuple[float, float]]</code> <p>Measure angle to this 2D point.</p> required <p>Returns:</p> Name Type Description <code>angle</code> <code>float</code> <p>Angle in radians.</p> Source code in <code>cython_extensions/geometry.pyi</code> <pre><code>def cy_angle_to(\n    from_pos: Union[Point2, tuple[float, float]],\n    to_pos: Union[Point2, tuple[float, float]],\n) -&gt; float:\n    \"\"\"Angle from point to other point in radians\n\n    Parameters\n    ----------\n    from_pos : Union[Point2, tuple[float, float]]\n        First 2D point.\n    to_pos : Union[Point2, tuple[float, float]]\n        Measure angle to this 2D point.\n\n    Returns\n    -------\n    angle : float\n        Angle in radians.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.geometry.cy_distance_to","title":"cy_distance_to","text":"<pre><code>cy_distance_to(p1, p2)\n</code></pre> <p>Check distance between two Point2 positions.</p> <p>Example: <pre><code>from cython_functions import cy_distance_to\n\ndist: float = cy_distance_to(\n    self.start_location, self.game_info.map_center\n)\n</code></pre> <pre><code>cy_distance_to(Point2, Point2)\n157 ns \u00b1 2.69 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000,000 loops each)\n\ncy_distance_to(unit1.position, unit2.position)\n219 ns \u00b1 10.5 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n\nPython alternative:\n\nPoint1.distance_to(Point2)\n386 ns \u00b1 2.71 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n\nunit1.distance_to(unit2)\n583 ns \u00b1 7.89 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>p1</code> <code>Union[Point2, tuple[float, float]]</code> <p>First point</p> required <code>p2</code> <code>Union[Point2, tuple[float, float]]</code> <p>Measure to this point</p> required <p>Returns:</p> Name Type Description <code>distance</code> <code>float</code> <p>Distance in tiles</p> Source code in <code>cython_extensions/geometry.pyi</code> <pre><code>def cy_distance_to(\n    p1: Union[Point2, tuple[float, float]], p2: Union[Point2, tuple[float, float]]\n) -&gt; float:\n    \"\"\"Check distance between two Point2 positions.\n\n    Example:\n    ```py\n    from cython_functions import cy_distance_to\n\n    dist: float = cy_distance_to(\n        self.start_location, self.game_info.map_center\n    )\n    ```\n    ```\n    cy_distance_to(Point2, Point2)\n    157 ns \u00b1 2.69 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000,000 loops each)\n\n    cy_distance_to(unit1.position, unit2.position)\n    219 ns \u00b1 10.5 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n\n    Python alternative:\n\n    Point1.distance_to(Point2)\n    386 ns \u00b1 2.71 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n\n    unit1.distance_to(unit2)\n    583 ns \u00b1 7.89 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n    ```\n\n    Parameters\n    ----------\n    p1 : Union[Point2, tuple[float, float]]\n        First point\n    p2 : Union[Point2, tuple[float, float]]\n        Measure to this point\n\n    Returns\n    -------\n    distance : float\n        Distance in tiles\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.geometry.cy_distance_to_squared","title":"cy_distance_to_squared","text":"<pre><code>cy_distance_to_squared(p1, p2)\n</code></pre> <p>Similar to <code>cy_distance_to</code> but without a square root operation. Use this for ~1.3x speedup</p> <p>Example: <pre><code>from cython_functions import cy_distance_to_squared\n\ndist: float = cy_distance_to_squared(\n    self.start_location, self.game_info.map_center\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>p1</code> <code>Union[Point2, tuple[float, float]]</code> <p>First point</p> required <code>p2</code> <code>Union[Point2, tuple[float, float]]</code> <p>Measure to this point</p> required <p>Returns:</p> Name Type Description <code>distance</code> <code>float</code> <p>Distance in tiles, squared</p> Source code in <code>cython_extensions/geometry.pyi</code> <pre><code>def cy_distance_to_squared(\n    p1: Union[Point2, tuple[float, float]], p2: Union[Point2, tuple[float, float]]\n) -&gt; float:\n    \"\"\"Similar to `cy_distance_to` but without a square root operation.\n    Use this for ~1.3x speedup\n\n    Example:\n    ```python\n    from cython_functions import cy_distance_to_squared\n\n    dist: float = cy_distance_to_squared(\n        self.start_location, self.game_info.map_center\n    )\n    ```\n\n    Parameters\n    ----------\n    p1 : Union[Point2, tuple[float, float]]\n        First point\n    p2 : Union[Point2, tuple[float, float]]\n        Measure to this point\n\n    Returns\n    -------\n    distance : float\n        Distance in tiles, squared\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.geometry.cy_find_average_angle","title":"cy_find_average_angle","text":"<pre><code>cy_find_average_angle(start_point, reference_point, points)\n</code></pre> <p>Find the average angle between the points and the reference point.</p> <p>Given a starting point, a reference point, and a list of points, find the average angle between the vectors from the starting point to the reference point and the starting point to the points.</p> <p>Example: <pre><code>from cython_extensions import cy_find_average_angle\n\nangle: float = cy_get_angle_between_points(\n    self.start_location,\n    self.game_info.map_center,\n    [w.position for w in self.workers]\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>start_point</code> <code>Union[Point2, tuple[float, float]]</code> <p>Origin for the vectors to the other given points.</p> required <code>reference_point</code> <code>Union[Point2, tuple[float, float]]</code> <p>Vector forming one leg of the angle.</p> required <code>points</code> <code>list[Point2]</code> <p>Points to calculate the angle between relative to the reference point.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Average angle in radians between the reference point and the given points.</p> Source code in <code>cython_extensions/geometry.pyi</code> <pre><code>def cy_find_average_angle(\n    start_point: Union[Point2, tuple[float, float]],\n    reference_point: Union[Point2, tuple[float, float]],\n    points: list[Point2],\n) -&gt; float:\n    \"\"\"Find the average angle between the points and the reference point.\n\n    Given a starting point, a reference point, and a list of points, find the average\n    angle between the vectors from the starting point to the reference point and the\n    starting point to the points.\n\n    Example:\n    ```py\n    from cython_extensions import cy_find_average_angle\n\n    angle: float = cy_get_angle_between_points(\n        self.start_location,\n        self.game_info.map_center,\n        [w.position for w in self.workers]\n    )\n    ```\n\n    Parameters\n    ----------\n    start_point :\n        Origin for the vectors to the other given points.\n    reference_point :\n        Vector forming one leg of the angle.\n    points :\n        Points to calculate the angle between relative to the reference point.\n\n    Returns\n    -------\n    float :\n        Average angle in radians between the reference point and the given points.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.geometry.cy_find_correct_line","title":"cy_find_correct_line","text":"<pre><code>cy_find_correct_line(points, base_location)\n</code></pre> <p>Given a list of points and a center point, find if there's a line such that all other points are above or below the line. Returns the line in the form Ax + By + C = 0 and the point that was used.</p> <p>If no such line is found, it returns ((0, 0, 0), ). <p>Parameters:</p> Name Type Description Default <code>points</code> <code>list[Point2]</code> <p>Points that need to be on one side of the line.</p> required <code>base_location</code> <code>Union[Point2, tuple[float, float]]</code> <p>Starting point for the line.</p> required <p>Returns:</p> Type Description <code>Tuple[Tuple[float, float, float], Tuple[float, float]] :</code> <p>First element is the coefficients of Ax + By + C = 0. Second element is the point used to form the line.</p> Source code in <code>cython_extensions/geometry.pyi</code> <pre><code>def cy_find_correct_line(\n    points: list[Point2], base_location: Union[Point2, tuple[float, float]]\n) -&gt; tuple[tuple[float], tuple[float]]:\n    \"\"\"\n    Given a list of points and a center point, find if there's a line such that all\n    other points are above or below the line. Returns the line in the form\n    Ax + By + C = 0 and the point that was used.\n\n    If no such line is found, it returns ((0, 0, 0), &lt;last_point_checked&gt;).\n\n    Parameters\n    ----------\n    points :\n        Points that need to be on one side of the line.\n    base_location :\n        Starting point for the line.\n\n    Returns\n    -------\n    Tuple[Tuple[float, float, float], Tuple[float, float]] :\n        First element is the coefficients of Ax + By + C = 0.\n        Second element is the point used to form the line.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.geometry.cy_get_angle_between_points","title":"cy_get_angle_between_points","text":"<pre><code>cy_get_angle_between_points(point_a, point_b)\n</code></pre> <p>Get the angle between two points as if they were vectors from the origin.</p> <p>Example: <pre><code>from cython_functions import cy_get_angle_between_points\n\nangle: float = cy_get_angle_between_points(\n    self.start_location, self.game_info.map_center\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>point_a</code> <code>Union[Point2, tuple[float, float]]</code> <p>First point</p> required <code>point_b</code> <code>Union[Point2, tuple[float, float]]</code> <p>Measure to this point</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> Source code in <code>cython_extensions/geometry.pyi</code> <pre><code>def cy_get_angle_between_points(\n    point_a: Union[Point2, tuple[float, float]],\n    point_b: Union[Point2, tuple[float, float]],\n) -&gt; float:\n    \"\"\"Get the angle between two points as if they were vectors from the origin.\n\n    Example:\n    ```py\n    from cython_functions import cy_get_angle_between_points\n\n    angle: float = cy_get_angle_between_points(\n        self.start_location, self.game_info.map_center\n    )\n    ```\n\n    Parameters\n    ----------\n    point_a :\n        First point\n    point_b :\n        Measure to this point\n\n    Returns\n    -------\n    float :\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.geometry.cy_towards","title":"cy_towards","text":"<pre><code>cy_towards(start_pos, target_pos, distance)\n</code></pre> <p>Get position from start_pos towards target_pos based on distance.</p> <p>Example: <pre><code>from cython_functions import cy_towards\n\nnew_pos: Tuple[float, float] = cy_towards(\n    self.start_location,\n    self.game_info.map_center,\n    12.0\n)\n</code></pre></p> <p>Note: For performance reasons this returns the point2 as a tuple, if a python-sc2 Point2 is required it's up to the user to convert it.</p> <p>Example: <pre><code>new_pos: Point2 = Point2(\n    cy_towards(\n        self.start_location, self.enemy_start_locations, 10.0\n    )\n)\n</code></pre></p> <p>Though for best performance it is recommended to simply work with the tuple if possible: <pre><code>new_pos: tuple[float, float] = cy_towards(\n    self.start_location, self.enemy_start_locations, 10.0\n)\n</code></pre></p> <pre><code>191 ns \u00b1 0.855 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000,000 loops each)\n\nPython-sc2's `start_pos.towards(target_pos, distance)` alternative:\n2.73 \u00b5s \u00b1 18.9 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>start_pos</code> <code>Point2</code> <p>Start from this 2D position.</p> required <code>target_pos</code> <code>Point2</code> <p>Go towards this 2D position.</p> required <code>distance</code> <code>float</code> <p>How far we go towards target_pos.</p> required <p>Returns:</p> Type Description <code>tuple[float, float] :</code> Source code in <code>cython_extensions/geometry.pyi</code> <pre><code>def cy_towards(\n    start_pos: Point2, target_pos: Point2, distance: float\n) -&gt; tuple[float, float]:\n    \"\"\"Get position from start_pos towards target_pos based on distance.\n\n    Example:\n    ```py\n    from cython_functions import cy_towards\n\n    new_pos: Tuple[float, float] = cy_towards(\n        self.start_location,\n        self.game_info.map_center,\n        12.0\n    )\n    ```\n\n    Note: For performance reasons this returns the point2 as a tuple, if a\n    python-sc2 Point2 is required it's up to the user to convert it.\n\n    Example:\n    ```py\n    new_pos: Point2 = Point2(\n        cy_towards(\n            self.start_location, self.enemy_start_locations, 10.0\n        )\n    )\n    ```\n\n    Though for best performance it is recommended to simply work with the tuple if possible:\n    ```py\n    new_pos: tuple[float, float] = cy_towards(\n        self.start_location, self.enemy_start_locations, 10.0\n    )\n    ```\n\n    ```\n    191 ns \u00b1 0.855 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000,000 loops each)\n\n    Python-sc2's `start_pos.towards(target_pos, distance)` alternative:\n    2.73 \u00b5s \u00b1 18.9 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n    ```\n\n\n    Parameters\n    ----------\n    start_pos :\n        Start from this 2D position.\n    target_pos :\n        Go towards this 2D position.\n    distance :\n        How far we go towards target_pos.\n\n    Returns\n    -------\n    tuple[float, float] :\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.geometry.cy_translate_point_along_line","title":"cy_translate_point_along_line","text":"<pre><code>cy_translate_point_along_line(point, a_value, distance)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Union[Point2, tuple[float, float]]</code> required <code>a_value</code> <code>float</code> required <code>distance</code> <code>float</code> required <p>Returns:</p> Type Description <code>Tuple[float, float]]</code> Source code in <code>cython_extensions/geometry.pyi</code> <pre><code>def cy_translate_point_along_line(\n    point: Union[Point2, tuple[float, float]], a_value: float, distance: float\n) -&gt; tuple[float, float]:\n    \"\"\"\n\n    Parameters\n    ----------\n    point :\n    a_value :\n    distance :\n\n    Returns\n    -------\n    Tuple[float, float]]\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.map_analysis.cy_flood_fill_grid","title":"cy_flood_fill_grid","text":"<pre><code>cy_flood_fill_grid(\n    start_point,\n    terrain_grid,\n    pathing_grid,\n    max_distance,\n    cutoff_points,\n)\n</code></pre> <p>Given a set of coordinates, draw a box that fits all the points.</p> <p>Example: <pre><code>from cython_extensions import cy_flood_fill_grid\n\nall_points = terrain_flood_fill(\n    start_point=self.start_location.rounded,\n    terrain_grid=self.game_info.terrain_height.data_numpy.T,\n    pathing_grid=self.game_info.pathing_grid.data_numpy.T,\n    max_distance=40,\n    choke_points={}\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>start_point</code> <code>Union[Point2, tuple]</code> <p>Start algorithm from here.</p> required <code>terrain_grid</code> <code>ndarray</code> <p>Numpy array containing heights for the map.</p> required <code>pathing_grid</code> <code>ndarray</code> <p>Numpy array containing pathing values for the map.</p> required <code>max_distance</code> <code>int</code> <p>The maximum distance the flood fill should reach before halting.</p> required <code>cutoff_points</code> <code>set</code> <p>Points which we don't want the algorithm to pass. Choke points are a good use case.</p> required <p>Returns:</p> Type Description <code>Tuple[Tuple[float, float], Tuple[float, float]] :</code> <p>A pair of coordinates that determine the box in the following format: ((xmin, xmax), (ymin, ymax))</p> Source code in <code>cython_extensions/map_analysis.pyi</code> <pre><code>def cy_flood_fill_grid(\n    start_point: Union[Point2, tuple],\n    terrain_grid: np.ndarray,\n    pathing_grid: np.ndarray,\n    max_distance: int,\n    cutoff_points: set,\n) -&gt; set[tuple]:\n    \"\"\"Given a set of coordinates, draw a box that fits\n    all the points.\n\n    Example:\n    ```py\n    from cython_extensions import cy_flood_fill_grid\n\n    all_points = terrain_flood_fill(\n        start_point=self.start_location.rounded,\n        terrain_grid=self.game_info.terrain_height.data_numpy.T,\n        pathing_grid=self.game_info.pathing_grid.data_numpy.T,\n        max_distance=40,\n        choke_points={}\n    )\n\n    ```\n\n    Parameters\n    ----------\n    start_point :\n        Start algorithm from here.\n    terrain_grid :\n        Numpy array containing heights for the map.\n    pathing_grid :\n        Numpy array containing pathing values for the map.\n    max_distance :\n        The maximum distance the flood fill should reach\n        before halting.\n    cutoff_points :\n        Points which we don't want the algorithm to pass.\n        Choke points are a good use case.\n\n\n    Returns\n    -------\n    Tuple[Tuple[float, float], Tuple[float, float]] :\n        A pair of coordinates that determine the box in the following format:\n        ((xmin, xmax), (ymin, ymax))\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.map_analysis.cy_get_bounding_box","title":"cy_get_bounding_box","text":"<pre><code>cy_get_bounding_box(coordinates)\n</code></pre> <p>Given a set of coordinates, draw a box that fits all the points.</p> <p>Example: <pre><code>from cython_extensions import cy_get_bounding_box\n\npoints: set[Point2] = {w.position for w in self.workers}\nraw_x_bounds, raw_y_bounds = cy_get_bounding_box(points)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>The points we want to draw a box around.</code> required <p>Returns:</p> Type Description <code>Tuple[Tuple[float, float], Tuple[float, float]] :</code> <p>A pair of coordinates that determine the box in the following format: ((xmin, xmax), (ymin, ymax))</p> Source code in <code>cython_extensions/map_analysis.pyi</code> <pre><code>def cy_get_bounding_box(\n    coordinates: set[Point2],\n) -&gt; tuple[tuple[float, float], tuple[float, float]]:\n    \"\"\"Given a set of coordinates, draw a box that fits\n    all the points.\n\n    Example:\n    ```py\n    from cython_extensions import cy_get_bounding_box\n\n    points: set[Point2] = {w.position for w in self.workers}\n    raw_x_bounds, raw_y_bounds = cy_get_bounding_box(points)\n\n    ```\n\n    Parameters\n    ----------\n    coordinates : The points we want to draw a box around.\n\n    Returns\n    -------\n    Tuple[Tuple[float, float], Tuple[float, float]] :\n        A pair of coordinates that determine the box in the following format:\n        ((xmin, xmax), (ymin, ymax))\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.numpy_helper.cy_all_points_below_max_value","title":"cy_all_points_below_max_value","text":"<pre><code>cy_all_points_below_max_value(grid, value, points_to_check)\n</code></pre> <p>Check points on grid, and return True if they are all below <code>value</code>.</p> <p>Example: <pre><code>from cython_extensions import cy_all_points_below_max_value\n\n# pretend grid has enemy influence added\ngrid = self.game_info.pathing_grid.data_numpy.T\nall_safe: bool = cy_all_points_below_max_value(\n    grid, 1.0, [self.start_location.rounded]\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>ndarray</code> <p>The grid to check.</p> required <code>value</code> <code>float</code> <p>The max value.</p> required <code>points_to_check</code> <code>list[tuple[int, int]]</code> <p>List of points we are checking.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Are all points_to_check below value?.</p> Source code in <code>cython_extensions/numpy_helper.pyi</code> <pre><code>def cy_all_points_below_max_value(\n    grid: np.ndarray, value: float, points_to_check: list[tuple[int, int]]\n) -&gt; bool:\n    \"\"\"Check points on grid, and return True if they are all below\n    `value`.\n\n    Example:\n    ```py\n    from cython_extensions import cy_all_points_below_max_value\n\n    # pretend grid has enemy influence added\n    grid = self.game_info.pathing_grid.data_numpy.T\n    all_safe: bool = cy_all_points_below_max_value(\n        grid, 1.0, [self.start_location.rounded]\n    )\n\n    ```\n\n    Parameters\n    ----------\n    grid :\n        The grid to check.\n    value :\n        The max value.\n    points_to_check :\n        List of points we are checking.\n    Returns\n    -------\n    bool :\n        Are all points_to_check below value?.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.numpy_helper.cy_all_points_have_value","title":"cy_all_points_have_value","text":"<pre><code>cy_all_points_have_value(grid, value, points)\n</code></pre> <p>Check points on grid, and return True if they are all equal <code>value</code>.</p> <p>Example: <pre><code>from cython_extensions import cy_all_points_have_value\n\n# pretend grid has enemy influence added\ngrid = self.game_info.pathing_grid.data_numpy.T\nall_safe: bool = cy_all_points_have_value(\n    grid, 1.0, [self.start_location.rounded]\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>ndarray</code> <p>The grid to check.</p> required <code>value</code> <code>float</code> <p>The max value.</p> required <code>points</code> <code>list[tuple[int, int]]</code> <p>List of points we are checking.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Are all points equal value?.</p> Source code in <code>cython_extensions/numpy_helper.pyi</code> <pre><code>def cy_all_points_have_value(\n    grid: np.ndarray, value: float, points: list[tuple[int, int]]\n) -&gt; bool:\n    \"\"\"Check points on grid, and return True if they are all equal\n    `value`.\n\n    Example:\n    ```py\n    from cython_extensions import cy_all_points_have_value\n\n    # pretend grid has enemy influence added\n    grid = self.game_info.pathing_grid.data_numpy.T\n    all_safe: bool = cy_all_points_have_value(\n        grid, 1.0, [self.start_location.rounded]\n    )\n\n    ```\n\n    Parameters\n    ----------\n    grid :\n        The grid to check.\n    value :\n        The max value.\n    points :\n        List of points we are checking.\n    Returns\n    -------\n    bool :\n        Are all points equal value?.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.numpy_helper.cy_last_index_with_value","title":"cy_last_index_with_value","text":"<pre><code>cy_last_index_with_value(grid, value, points)\n</code></pre> <p>Finds the last index with the matching value, stopping as soon as a value doesn't match. Returns -1 if points is empty or the first value doesn't match</p> <p>Example: <pre><code>from cython_extensions import cy_last_index_with_value\n\ngrid = self.game_info.pathing_grid.data_numpy.T\npoints: list[Point2] = [w.position.rounded for w in self.workers]\nlast_pathable_index = cy_last_index_with_value(grid, 1, points)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>ndarray</code> <p>The grid to check <code>points</code> on.</p> required <code>value</code> <code>int</code> <p>The value we are looking for.</p> required <code>points</code> <code>list[tuple[int, int]]</code> <p>Points we want to check</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The last index in <code>points</code> that has <code>value</code></p> Source code in <code>cython_extensions/numpy_helper.pyi</code> <pre><code>def cy_last_index_with_value(\n    grid: np.ndarray, value: int, points: list[tuple[int, int]]\n) -&gt; int:\n    \"\"\"Finds the last index with the matching value, stopping as soon as a\n    value doesn't match.\n    Returns -1 if points is empty or the first value doesn't match\n\n    Example:\n    ```py\n    from cython_extensions import cy_last_index_with_value\n\n    grid = self.game_info.pathing_grid.data_numpy.T\n    points: list[Point2] = [w.position.rounded for w in self.workers]\n    last_pathable_index = cy_last_index_with_value(grid, 1, points)\n\n    ```\n\n    Parameters\n    ----------\n    grid :\n        The grid to check `points` on.\n    value :\n        The value we are looking for.\n    points :\n        Points we want to check\n\n    Returns\n    -------\n    int :\n        The last index in `points` that has `value`\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.numpy_helper.cy_point_below_value","title":"cy_point_below_value","text":"<pre><code>cy_point_below_value(\n    grid, position, weight_safety_limit=1.0\n)\n</code></pre> <p>Check a position on a 2D grid. Is it below <code>weight_safety_limit</code>? Useful for checking enemy influence on a position.</p> <p>Example: <pre><code>from cython_extensions import cy_point_below_value\n\n# pretend grid has enemy influence added\ngrid = self.game_info.pathing_grid.data_numpy.T\nsafe: bool = cy_point_below_value(grid, self.start_location.rounded)\n</code></pre></p> <pre><code>987 ns \u00b1 10.1 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n\nPython alternative:\n4.66 \u00b5s \u00b1 64.8 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>ndarray</code> <p>The grid to check.</p> required <code>position</code> <code>tuple[int, int]</code> <p>2D coordinate to check on grid.</p> required <code>weight_safety_limit</code> <code>(default = 1.0)</code> <p>We want to check of point is less or equal to this.</p> <code>1.0</code> <p>Returns:</p> Name Type Description <code>int</code> <code>bool</code> <p>The last index in <code>points</code> that has <code>value</code></p> Source code in <code>cython_extensions/numpy_helper.pyi</code> <pre><code>def cy_point_below_value(\n    grid: np.ndarray, position: tuple[int, int], weight_safety_limit: float = 1.0\n) -&gt; bool:\n    \"\"\"Check a position on a 2D grid.\n    Is it below `weight_safety_limit`?\n    Useful for checking enemy influence on a position.\n\n    Example:\n    ```py\n    from cython_extensions import cy_point_below_value\n\n    # pretend grid has enemy influence added\n    grid = self.game_info.pathing_grid.data_numpy.T\n    safe: bool = cy_point_below_value(grid, self.start_location.rounded)\n    ```\n\n    ```\n    987 ns \u00b1 10.1 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n\n    Python alternative:\n    4.66 \u00b5s \u00b1 64.8 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n    ```\n\n    Parameters\n    ----------\n    grid :\n        The grid to check.\n    position :\n        2D coordinate to check on grid.\n    weight_safety_limit : (default = 1.0)\n        We want to check of point is less or equal to this.\n    Returns\n    -------\n    int :\n        The last index in `points` that has `value`\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.numpy_helper.cy_points_with_value","title":"cy_points_with_value","text":"<pre><code>cy_points_with_value(grid, value, points)\n</code></pre> <p>Check points on grid, and return those that equal <code>value</code></p> <p>Example: <pre><code>from cython_extensions import cy_points_with_value\nimport numpy as np\n\n# pretend grid has enemy influence added\ngrid: np.ndarray = self.game_info.pathing_grid.data_numpy.T\nsafe: bool = cy_points_with_value(\n    grid, 1.0, [self.start_location.rounded]\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>ndarray</code> <p>The grid to check.</p> required <code>value</code> <code>float</code> <p>2D coordinate to check on grid.</p> required <code>points</code> <code>list[tuple[int, int]]</code> <p>List of points we are checking.</p> required <p>Returns:</p> Type Description <code>list[tuple[int, int]] :</code> <p>All points that equal <code>value</code> on grid.</p> Source code in <code>cython_extensions/numpy_helper.pyi</code> <pre><code>def cy_points_with_value(\n    grid: np.ndarray, value: float, points: list[tuple[int, int]]\n) -&gt; list[tuple[int, int]]:\n    \"\"\"Check points on grid, and return those that equal `value`\n\n    Example:\n    ```py\n    from cython_extensions import cy_points_with_value\n    import numpy as np\n\n    # pretend grid has enemy influence added\n    grid: np.ndarray = self.game_info.pathing_grid.data_numpy.T\n    safe: bool = cy_points_with_value(\n        grid, 1.0, [self.start_location.rounded]\n    )\n\n    ```\n\n    Parameters\n    ----------\n    grid :\n        The grid to check.\n    value :\n        2D coordinate to check on grid.\n    points :\n        List of points we are checking.\n    Returns\n    -------\n    list[tuple[int, int]] :\n        All points that equal `value` on grid.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.placement_solver.cy_can_place_structure","title":"cy_can_place_structure","text":"<pre><code>cy_can_place_structure(\n    building_origin,\n    building_size,\n    creep_grid,\n    placement_grid,\n    pathing_grid,\n    avoid_creep=True,\n    include_addon=False,\n)\n</code></pre> <p>Simulate whether a structure can be placed at <code>building_origin</code> Fast alternative to python-sc2 <code>can_place</code></p> <p>Example: <pre><code>from cython_extensions import cy_can_place_structure\n\ncan_place: bool = cy_can_place_structure(\n    (155, 45),\n    (3, 3),\n    self.ai.state.creep.data_numpy,\n    self.ai.game_info.placement_grid.data_numpy,\n    self.ai.game_info.pathing_grid.data_numpy,\n    avoid_creep=self.race != Race.Zerg,\n    include_addon=False,\n)\n</code></pre></p> <pre><code>1.21 \u00b5s \u00b1 891 ns per loop (mean \u00b1 std. dev. of 1000 runs, 10 loops each)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>building_origin</code> <code>tuple[int, int]</code> <p>The top left corner of the intended structure.</p> required <code>building_size</code> <code>tuple[int, int]</code> <p>For example: (3, 3) for barracks. (2, 2) for depot (5, 5) for command center</p> required <code>creep_grid</code> <code>ndarray</code> <p>Creep grid</p> required <code>placement_grid</code> <code>ndarray</code> required <code>pathing_grid</code> <code>ndarray</code> required <code>avoid_creep</code> <code>(default = True)</code> <p>ENSURE THIS IS FALSE IF CHECKING ZERG STRUCTURES</p> <code>True</code> <code>include_addon</code> <code>(default = False)</code> <p>Check if there is room for addon too?</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Can we place structure at building_origin?.</p> Source code in <code>cython_extensions/placement_solver.pyi</code> <pre><code>def cy_can_place_structure(\n    building_origin: tuple[int, int],\n    building_size: tuple[int, int],\n    creep_grid: np.ndarray,\n    placement_grid: np.ndarray,\n    pathing_grid: np.ndarray,\n    avoid_creep: bool = True,\n    include_addon: bool = False,\n) -&gt; bool:\n    \"\"\"Simulate whether a structure can be placed at `building_origin`\n    Fast alternative to python-sc2 `can_place`\n\n    Example:\n    ```py\n    from cython_extensions import cy_can_place_structure\n\n    can_place: bool = cy_can_place_structure(\n        (155, 45),\n        (3, 3),\n        self.ai.state.creep.data_numpy,\n        self.ai.game_info.placement_grid.data_numpy,\n        self.ai.game_info.pathing_grid.data_numpy,\n        avoid_creep=self.race != Race.Zerg,\n        include_addon=False,\n    )\n    ```\n\n    ```\n    1.21 \u00b5s \u00b1 891 ns per loop (mean \u00b1 std. dev. of 1000 runs, 10 loops each)\n    ```\n\n    Parameters\n    ----------\n    building_origin :\n        The top left corner of the intended structure.\n    building_size :\n        For example: (3, 3) for barracks.\n        (2, 2) for depot\n        (5, 5) for command center\n    creep_grid :\n        Creep grid\n    placement_grid :\n    pathing_grid :\n    avoid_creep : (default = True)\n        ENSURE THIS IS FALSE IF CHECKING ZERG STRUCTURES\n    include_addon : (default = False)\n        Check if there is room for addon too?\n\n\n    Returns\n    -------\n    bool :\n        Can we place structure at building_origin?.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.placement_solver.cy_find_building_locations","title":"cy_find_building_locations","text":"<pre><code>cy_find_building_locations(\n    kernel,\n    x_stride,\n    y_stride,\n    x_bounds,\n    y_bounds,\n    creep_grid,\n    placement_grid,\n    pathing_grid,\n    points_to_avoid_grid,\n    avoid_creep=True,\n    include_addon=False,\n)\n</code></pre> <p>Use a convolution pass to find all possible building locations in an area Check <code>ares-sc2</code> for a full example of using this to calculate building formations.</p> <p>https://github.com/AresSC2/ares-sc2/blob/main/src/ares/managers/placement_manager.py</p> <p>Example: <pre><code>from cython_extensions import cy_find_building_locations\n\n# find 3x3 locations, making room for addons.\n# check out map_analysis.cy_get_bounding_box to calculate\n# raw_x_bounds and raw_x_bounds\nthree_by_three_positions = cy_find_building_locations(\n    kernel=np.ones((5, 3), dtype=np.uint8),\n    x_stride=5,\n    y_stride=3,\n    x_bounds=raw_x_bounds,\n    y_bounds=raw_y_bounds,\n    creep_grid=creep_grid,\n    placement_grid=placement_grid,\n    pathing_grid=pathing_grid,\n    points_to_avoid_grid=self.points_to_avoid_grid,\n    building_width=3,\n    building_height=3,\n    avoid_creep=True\n)\n</code></pre></p> <pre><code>64.8 \u00b5s \u00b1 4.05 \u00b5s per loop (mean \u00b1 std. dev. of 1000 runs, 10 loops each)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>kernel</code> <code>ndarray</code> <p>The size of the sliding window that scans this area.</p> required <code>x_stride</code> <code>int</code> <p>The x distance the kernel window moves each step.</p> required <code>y_stride</code> <code>int</code> <p>The y distance the kernel window moves downwards.</p> required <code>x_bounds</code> <code>tuple[int, int]</code> <p>The starting point of the algorithm.</p> required <code>y_bounds</code> <code>tuple[int, int]</code> <p>The end point of the algorithm.</p> required <code>creep_grid</code> <code>ndarray</code> required <code>placement_grid</code> <code>ndarray</code> required <code>pathing_grid</code> <code>ndarray</code> required <code>points_to_avoid_grid</code> <code>ndarray</code> <p>Grid containing <code>1</code>s where we shouldn't place anything.</p> required <code>avoid_creep</code> <code>(default = True)</code> <p>ENSURE THIS IS FALSE IF CHECKING ZERG STRUCTURES</p> <code>True</code> <code>include_addon</code> <code>(default = False)</code> <p>Check if there is room for addon too?</p> <code>False</code> <p>Returns:</p> Type Description <code>list[tuple[float, float]] :</code> <p>Final list of positions that make up the building formation.</p> Source code in <code>cython_extensions/placement_solver.pyi</code> <pre><code>def cy_find_building_locations(\n    kernel: np.ndarray,\n    x_stride: int,\n    y_stride: int,\n    x_bounds: tuple[int, int],\n    y_bounds: tuple[int, int],\n    creep_grid: np.ndarray,\n    placement_grid: np.ndarray,\n    pathing_grid: np.ndarray,\n    points_to_avoid_grid: np.ndarray,\n    avoid_creep: bool = True,\n    include_addon: bool = False,\n) -&gt; list[tuple[float, float]]:\n    \"\"\"Use a convolution pass to find all possible building locations in an area\n    Check `ares-sc2` for a full example of using this to calculate\n    building formations.\n\n    https://github.com/AresSC2/ares-sc2/blob/main/src/ares/managers/placement_manager.py\n\n    Example:\n    ```py\n    from cython_extensions import cy_find_building_locations\n\n    # find 3x3 locations, making room for addons.\n    # check out map_analysis.cy_get_bounding_box to calculate\n    # raw_x_bounds and raw_x_bounds\n    three_by_three_positions = cy_find_building_locations(\n        kernel=np.ones((5, 3), dtype=np.uint8),\n        x_stride=5,\n        y_stride=3,\n        x_bounds=raw_x_bounds,\n        y_bounds=raw_y_bounds,\n        creep_grid=creep_grid,\n        placement_grid=placement_grid,\n        pathing_grid=pathing_grid,\n        points_to_avoid_grid=self.points_to_avoid_grid,\n        building_width=3,\n        building_height=3,\n        avoid_creep=True\n    )\n\n    ```\n\n    ```\n    64.8 \u00b5s \u00b1 4.05 \u00b5s per loop (mean \u00b1 std. dev. of 1000 runs, 10 loops each)\n    ```\n\n    Parameters\n    ----------\n    kernel :\n        The size of the sliding window that scans this area.\n    x_stride :\n        The x distance the kernel window moves each step.\n    y_stride :\n        The y distance the kernel window moves downwards.\n    x_bounds :\n        The starting point of the algorithm.\n    y_bounds :\n        The end point of the algorithm.\n    creep_grid :\n    placement_grid :\n    pathing_grid :\n    points_to_avoid_grid :\n        Grid containing `1`s where we shouldn't place anything.\n    avoid_creep : (default = True)\n        ENSURE THIS IS FALSE IF CHECKING ZERG STRUCTURES\n    include_addon : (default = False)\n        Check if there is room for addon too?\n\n\n    Returns\n    -------\n    list[tuple[float, float]] :\n        Final list of positions that make up the building formation.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.units_utils.cy_center","title":"cy_center","text":"<pre><code>cy_center(units)\n</code></pre> <p>Given some units, find the center point.</p> <p>Example: <pre><code>from ares.cython_functions.units_utils import cy_center\n\ncentroid: Tuple[float, float] = cy_center(self.workers)\n\n# centroid_point2 = Point2(centroid)\n</code></pre></p> <pre><code>54.2 \u00b5s \u00b1 137 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n\n`python-sc2`'s `units.center` alternative:\n107 \u00b5s \u00b1 255 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>units</code> <code>Union[Units, list[Unit]]</code> required <p>Returns:</p> Type Description <code>tuple[float, float] :</code> <p>Centroid of all units positions</p> Source code in <code>cython_extensions/units_utils.pyi</code> <pre><code>def cy_center(units: Union[Units, list[Unit]]) -&gt; tuple[float, float]:\n    \"\"\"Given some units, find the center point.\n\n\n    Example:\n    ```py\n    from ares.cython_functions.units_utils import cy_center\n\n    centroid: Tuple[float, float] = cy_center(self.workers)\n\n    # centroid_point2 = Point2(centroid)\n    ```\n\n    ```\n    54.2 \u00b5s \u00b1 137 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n\n    `python-sc2`'s `units.center` alternative:\n    107 \u00b5s \u00b1 255 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n    ```\n\n    Parameters\n    ----------\n    units :\n\n    Returns\n    -------\n    tuple[float, float] :\n        Centroid of all units positions\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.units_utils.cy_closest_to","title":"cy_closest_to","text":"<pre><code>cy_closest_to(position, units)\n</code></pre> <p>Iterate through <code>units</code> to find closest to <code>position</code>.</p> <p>Example: <pre><code>from cython_functions import cy_closest_to\nfrom sc2.unit import Unit\n\nclosest_unit: Unit = cy_closest_to(self.start_location, self.workers)\n</code></pre></p> <pre><code>14.3 \u00b5s \u00b1 135 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n\npython-sc2's `units.closest_to()` alternative:\n98.9 \u00b5s \u00b1 240 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n\nIf using python-sc2's `units.closest_to(Point2):\n200 \u00b5s \u00b1 1.02 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1,000 loops each)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>Union[Point2, tuple[float, float]]</code> <p>Position to measure distance from.</p> required <code>units</code> <code>Union[Units, list[Unit]]</code> <p>Collection of units we want to check.</p> required <p>Returns:</p> Name Type Description <code>Unit</code> <code>Unit</code> <p>Unit closest to <code>position</code>.</p> Source code in <code>cython_extensions/units_utils.pyi</code> <pre><code>def cy_closest_to(\n    position: Union[Point2, tuple[float, float]], units: Union[Units, list[Unit]]\n) -&gt; Unit:\n    \"\"\"Iterate through `units` to find closest to `position`.\n\n    Example:\n    ```py\n    from cython_functions import cy_closest_to\n    from sc2.unit import Unit\n\n    closest_unit: Unit = cy_closest_to(self.start_location, self.workers)\n    ```\n\n    ```\n    14.3 \u00b5s \u00b1 135 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n\n    python-sc2's `units.closest_to()` alternative:\n    98.9 \u00b5s \u00b1 240 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n\n    If using python-sc2's `units.closest_to(Point2):\n    200 \u00b5s \u00b1 1.02 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1,000 loops each)\n    ```\n\n    Parameters\n    ----------\n    position :\n        Position to measure distance from.\n    units :\n        Collection of units we want to check.\n\n    Returns\n    -------\n    Unit :\n        Unit closest to `position`.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.units_utils.cy_find_units_center_mass","title":"cy_find_units_center_mass","text":"<pre><code>cy_find_units_center_mass(units, distance)\n</code></pre> <p>Given some units, find the center mass</p> <p>Example: <pre><code>from cython_functions import cy_find_units_center_mass\nfrom sc2.position import Point2\n\ncenter_mass: Point2\nnum_units: int\ncenter_mass, num_units = cy_find_units_center_mass(self.units, 10.0)\n</code></pre></p> <pre><code>47.8 ms \u00b1 674 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n\npython alternative:\n322 ms \u00b1 5.2 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>units</code> <code>Union[Units, list[Unit]]</code> <p>Position to measure distance from.</p> required <code>distance</code> <code>float</code> <p>Collection of units we want to check.</p> required <p>Returns:</p> Type Description <code>Tuple[Point2, int] :</code> <p>The center mass, and how many units are within <code>distance</code> of the center mass.</p> Source code in <code>cython_extensions/units_utils.pyi</code> <pre><code>def cy_find_units_center_mass(\n    units: Union[Units, list[Unit]], distance: float\n) -&gt; Unit:\n    \"\"\"Given some units, find the center mass\n\n    Example:\n    ```py\n    from cython_functions import cy_find_units_center_mass\n    from sc2.position import Point2\n\n    center_mass: Point2\n    num_units: int\n    center_mass, num_units = cy_find_units_center_mass(self.units, 10.0)\n    ```\n\n    ```\n    47.8 ms \u00b1 674 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n\n    python alternative:\n    322 ms \u00b1 5.2 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n    ```\n\n    Parameters\n    ----------\n    units :\n        Position to measure distance from.\n    distance :\n        Collection of units we want to check.\n\n    Returns\n    -------\n    Tuple[Point2, int] :\n        The center mass, and how many units are within `distance`\n        of the center mass.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.units_utils.cy_in_attack_range","title":"cy_in_attack_range","text":"<pre><code>cy_in_attack_range(unit, units, bonus_distance=0.0)\n</code></pre> <p>Find all units that unit can shoot at.</p> <p>Doesn't check if the unit weapon is ready. See: <code>cython_functions.attack_ready</code></p> <p>Example: <pre><code>from cython_functions import cy_in_attack_range\nfrom sc2.unit import Unit\n\nin_attack_range: list[Unit] = cy_in_attack_range(self.workers[0], self.enemy_units)\n</code></pre></p> <pre><code>7.28 \u00b5s \u00b1 26.3 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n\npython-sc2's `units.in_attack_range_of(unit)` alternative:\n30.4 \u00b5s \u00b1 271 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>unit</code> <code>Unit</code> <p>Position to measure distance from.</p> required <code>units</code> <code>Union[Units, list[Unit]]</code> <p>Collection of units we want to check.</p> required <code>bonus_distance</code> <code>float</code> <code>0.0</code> <p>Returns:</p> Type Description <code>list[Unit] :</code> <p>Units that are in attack range of <code>unit</code>.</p> Source code in <code>cython_extensions/units_utils.pyi</code> <pre><code>def cy_in_attack_range(\n    unit: Unit, units: Union[Units, list[Unit]], bonus_distance: float = 0.0\n) -&gt; list[Unit]:\n    \"\"\"Find all units that unit can shoot at.\n\n    Doesn't check if the unit weapon is ready. See:\n    `cython_functions.attack_ready`\n\n    Example:\n    ```py\n    from cython_functions import cy_in_attack_range\n    from sc2.unit import Unit\n\n    in_attack_range: list[Unit] = cy_in_attack_range(self.workers[0], self.enemy_units)\n    ```\n\n    ```\n    7.28 \u00b5s \u00b1 26.3 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n\n    python-sc2's `units.in_attack_range_of(unit)` alternative:\n    30.4 \u00b5s \u00b1 271 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n    ```\n\n    Parameters\n    ----------\n    unit :\n        Position to measure distance from.\n    units :\n        Collection of units we want to check.\n    bonus_distance :\n\n    Returns\n    -------\n    list[Unit] :\n        Units that are in attack range of `unit`.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.units_utils.cy_sorted_by_distance_to","title":"cy_sorted_by_distance_to","text":"<pre><code>cy_sorted_by_distance_to(units, position, reverse=False)\n</code></pre> <p>Sort units by distance to <code>position</code></p> <p>Example: <pre><code>from cython_functions import cy_sorted_by_distance_to\nfrom sc2.unit import Unit\n\nsorted_by_distance: list[Unit] = cy_sorted_by_distance_to(\n    self.workers, self.start_location\n)\n</code></pre></p> <pre><code>33.7 \u00b5s \u00b1 190 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n\npython-sc2's `units.sorted_by_distance_to(position)` alternative:\n246 \u00b5s \u00b1 830 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000 loops each)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>units</code> <code>Union[Units, list[Unit]]</code> <p>Units we want to sort.</p> required <code>position</code> <code>Point2</code> <p>Sort by distance to this position.</p> required <code>reverse</code> <code>bool</code> <p>Not currently used.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[Unit] :</code> <p>Units sorted by distance to position.</p> Source code in <code>cython_extensions/units_utils.pyi</code> <pre><code>def cy_sorted_by_distance_to(\n    units: Union[Units, list[Unit]], position: Point2, reverse: bool = False\n) -&gt; list[Unit]:\n    \"\"\"Sort units by distance to `position`\n\n    Example:\n    ```py\n    from cython_functions import cy_sorted_by_distance_to\n    from sc2.unit import Unit\n\n    sorted_by_distance: list[Unit] = cy_sorted_by_distance_to(\n        self.workers, self.start_location\n    )\n    ```\n\n    ```\n    33.7 \u00b5s \u00b1 190 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n\n    python-sc2's `units.sorted_by_distance_to(position)` alternative:\n    246 \u00b5s \u00b1 830 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000 loops each)\n    ```\n\n    Parameters\n    ----------\n    units :\n        Units we want to sort.\n    position :\n        Sort by distance to this position.\n    reverse :\n        Not currently used.\n    Returns\n    -------\n    list[Unit] :\n        Units sorted by distance to position.\n\n    \"\"\"\n    ...\n</code></pre>"}]}